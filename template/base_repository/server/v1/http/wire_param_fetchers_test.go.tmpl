package httpserver

import (
	"context"
	"fmt"
	"testing"

	"{{ .OutputRepository }}/internal/logging/v1/noop"
	"{{ .OutputRepository }}/models/v1"
{{ range $x, $import := .IterableServicesImports }}
	"{{ $import }}"
{{ end }}
	"{{ .OutputRepository }}/services/v1/oauth2clients"
	"{{ .OutputRepository }}/services/v1/users"
	"{{ .OutputRepository }}/services/v1/webhooks"

	"github.com/go-chi/chi"
	"github.com/stretchr/testify/assert"
)
{{ range $i, $dt := .DataTypes }}
func TestProvide{{ pascal $dt.Name }}UserIDFetcher(T *testing.T) {
	T.Parallel()

	T.Run("obligatory", func(t *testing.T) {
		_ = Provide{{ pascal $dt.Name }}UserIDFetcher()
	})
}
{{ end }}
{{ range $i, $dt := .DataTypes }}
func TestProvide{{ pascal $dt.Name }}IDFetcher(T *testing.T) {
	T.Parallel()

	T.Run("obligatory", func(t *testing.T) {
		_ = Provide{{ pascal $dt.Name }}IDFetcher(noop.ProvideNoopLogger())
	})
}
{{ end }}

func TestProvideUsernameFetcher(T *testing.T) {
	T.Parallel()

	T.Run("obligatory", func(t *testing.T) {
		_ = ProvideUsernameFetcher(noop.ProvideNoopLogger())
	})
}

func TestProvideAuthUserIDFetcher(T *testing.T) {
	T.Parallel()

	T.Run("obligatory", func(t *testing.T) {
		_ = ProvideAuthUserIDFetcher()
	})
}

func TestProvideWebhooksUserIDFetcher(T *testing.T) {
	T.Parallel()

	T.Run("obligatory", func(t *testing.T) {
		_ = ProvideWebhooksUserIDFetcher()
	})
}

func TestProvideWebhookIDFetcher(T *testing.T) {
	T.Parallel()

	T.Run("obligatory", func(t *testing.T) {
		_ = ProvideWebhookIDFetcher(noop.ProvideNoopLogger())
	})
}

func TestProvideOAuth2ServiceClientIDFetcher(T *testing.T) {
	T.Parallel()

	T.Run("obligatory", func(t *testing.T) {
		_ = ProvideOAuth2ServiceClientIDFetcher(noop.ProvideNoopLogger())
	})
}

func TestUserIDFetcher(T *testing.T) {
	T.Parallel()

	T.Run("obligatory", func(t *testing.T) {
		req := buildRequest(t)
		expected := uint64(123)
		req = req.WithContext(context.WithValue(req.Context(), models.UserIDKey, expected))
		actual := UserIDFetcher(req)

		assert.Equal(t, expected, actual)
	})
}

func Test_buildChiUserIDFetcher(T *testing.T) {
	T.Parallel()

	T.Run("happy path", func(t *testing.T) {
		fn := buildChiUserIDFetcher(noop.ProvideNoopLogger())
		expected := uint64(123)

		req := buildRequest(t)

		req = req.WithContext(context.WithValue(req.Context(), chi.RouteCtxKey, &chi.Context{
			URLParams: chi.RouteParams{
				Keys:   []string{users.URIParamKey},
				Values: []string{fmt.Sprintf("%d", expected)},
			},
		}))

		actual := fn(req)
		assert.Equal(t, expected, actual)
	})

	T.Run("with invalid value somehow", func(t *testing.T) {
		// NOTE: This will probably never happen in dev or production
		fn := buildChiUserIDFetcher(noop.ProvideNoopLogger())
		expected := uint64(0)

		req := buildRequest(t)

		req = req.WithContext(context.WithValue(req.Context(), chi.RouteCtxKey, &chi.Context{
			URLParams: chi.RouteParams{
				Keys:   []string{users.URIParamKey},
				Values: []string{"expected"},
			},
		}))

		actual := fn(req)
		assert.Equal(t, expected, actual)
	})
}

{{ range $i, $dt := .DataTypes }}
func Test_buildChi{{ pascal $dt.Name }}IDFetcher(T *testing.T) {
	T.Parallel()

	T.Run("happy path", func(t *testing.T) {
		fn := buildChi{{ pascal $dt.Name }}IDFetcher(noop.ProvideNoopLogger())
		expected := uint64(123)

		req := buildRequest(t)

		req = req.WithContext(context.WithValue(req.Context(), chi.RouteCtxKey, &chi.Context{
			URLParams: chi.RouteParams{
				Keys:   []string{ {{ lower $dt.Name }}s.URIParamKey },
				Values: []string{fmt.Sprintf("%d", expected)},
			},
		}))

		actual := fn(req)
		assert.Equal(t, expected, actual)
	})

	T.Run("with invalid value somehow", func(t *testing.T) {
		// NOTE: This will probably never happen in dev or production
		fn := buildChi{{ pascal $dt.Name }}IDFetcher(noop.ProvideNoopLogger())
		expected := uint64(0)

		req := buildRequest(t)

		req = req.WithContext(context.WithValue(req.Context(), chi.RouteCtxKey, &chi.Context{
			URLParams: chi.RouteParams{
				Keys:   []string{ {{ lower $dt.Name }}s.URIParamKey },
				Values: []string{"expected"},
			},
		}))

		actual := fn(req)
		assert.Equal(t, expected, actual)
	})
}
{{ end }}

func Test_buildChiWebhookIDFetcher(T *testing.T) {
	T.Parallel()

	T.Run("happy path", func(t *testing.T) {
		fn := buildChiWebhookIDFetcher(noop.ProvideNoopLogger())
		expected := uint64(123)

		req := buildRequest(t)

		req = req.WithContext(context.WithValue(req.Context(), chi.RouteCtxKey, &chi.Context{
			URLParams: chi.RouteParams{
				Keys:   []string{webhooks.URIParamKey},
				Values: []string{fmt.Sprintf("%d", expected)},
			},
		}))

		actual := fn(req)
		assert.Equal(t, expected, actual)
	})

	T.Run("with invalid value somehow", func(t *testing.T) {
		// NOTE: This will probably never happen in dev or production
		fn := buildChiWebhookIDFetcher(noop.ProvideNoopLogger())
		expected := uint64(0)

		req := buildRequest(t)

		req = req.WithContext(context.WithValue(req.Context(), chi.RouteCtxKey, &chi.Context{
			URLParams: chi.RouteParams{
				Keys:   []string{webhooks.URIParamKey},
				Values: []string{"expected"},
			},
		}))

		actual := fn(req)
		assert.Equal(t, expected, actual)
	})
}

func Test_buildChiOAuth2ClientIDFetcher(T *testing.T) {
	T.Parallel()

	T.Run("happy path", func(t *testing.T) {
		fn := buildChiOAuth2ClientIDFetcher(noop.ProvideNoopLogger())
		expected := uint64(123)

		req := buildRequest(t)

		req = req.WithContext(context.WithValue(req.Context(), chi.RouteCtxKey, &chi.Context{
			URLParams: chi.RouteParams{
				Keys:   []string{oauth2clients.URIParamKey},
				Values: []string{fmt.Sprintf("%d", expected)},
			},
		}))

		actual := fn(req)
		assert.Equal(t, expected, actual)
	})

	T.Run("with invalid value somehow", func(t *testing.T) {
		// NOTE: This will probably never happen in dev or production
		fn := buildChiOAuth2ClientIDFetcher(noop.ProvideNoopLogger())
		expected := uint64(0)

		req := buildRequest(t)

		req = req.WithContext(context.WithValue(req.Context(), chi.RouteCtxKey, &chi.Context{
			URLParams: chi.RouteParams{
				Keys:   []string{oauth2clients.URIParamKey},
				Values: []string{"expected"},
			},
		}))

		actual := fn(req)
		assert.Equal(t, expected, actual)
	})
}
