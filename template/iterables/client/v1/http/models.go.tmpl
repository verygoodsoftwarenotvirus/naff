package client

import (
	"context"
	"net/http"
	"strconv"

	"{{ .OutputRepository }}/models/v1"

	"github.com/pkg/errors"
)

const (
	{{ camelCase .Name }}sBasePath = "{{ camelCase .Name }}s"
)

// BuildGet{{ .Name }}Request builds an HTTP request for fetching an {{ camelCase .Name }}
func (c *V1Client) BuildGet{{ .Name }}Request(ctx context.Context, id uint64) (*http.Request, error) {
	uri := c.BuildURL(nil, {{ camelCase .Name }}sBasePath, strconv.FormatUint(id, 10))

	return http.NewRequest(http.MethodGet, uri, nil)
}

// Get{{ .Name }} retrieves an {{ camelCase .Name }}
func (c *V1Client) Get{{ .Name }}(ctx context.Context, id uint64) ({{ camelCase .Name }} *models.{{ .Name }}, err error) {
	req, err := c.BuildGet{{ .Name }}Request(ctx, id)
	if err != nil {
		return nil, errors.Wrap(err, "building request")
	}

	if retrieveErr := c.retrieve(ctx, req, &{{ camelCase .Name }}); retrieveErr != nil {
		return nil, retrieveErr
	}

	return {{ camelCase .Name }}, nil
}

// BuildGet{{ .Name }}sRequest builds an HTTP request for fetching {{ camelCase .Name }}s
func (c *V1Client) BuildGet{{ .Name }}sRequest(ctx context.Context, filter *models.QueryFilter) (*http.Request, error) {
	uri := c.BuildURL(filter.ToValues(), {{ camelCase .Name }}sBasePath)

	return http.NewRequest(http.MethodGet, uri, nil)
}

// Get{{ .Name }}s retrieves a list of {{ camelCase .Name }}s
func (c *V1Client) Get{{ .Name }}s(ctx context.Context, filter *models.QueryFilter) ({{ camelCase .Name }}s *models.{{ .Name }}List, err error) {
	req, err := c.BuildGet{{ .Name }}sRequest(ctx, filter)
	if err != nil {
		return nil, errors.Wrap(err, "building request")
	}

	if retrieveErr := c.retrieve(ctx, req, &{{ camelCase .Name }}s); retrieveErr != nil {
		return nil, retrieveErr
	}

	return {{ camelCase .Name }}s, nil
}

// BuildCreate{{ .Name }}Request builds an HTTP request for creating an {{ camelCase .Name }}
func (c *V1Client) BuildCreate{{ .Name }}Request(ctx context.Context, body *models.{{ .Name }}CreationInput) (*http.Request, error) {
	uri := c.BuildURL(nil, {{ camelCase .Name }}sBasePath)

	return c.buildDataRequest(http.MethodPost, uri, body)
}

// Create{{ .Name }} creates an {{ camelCase .Name }}
func (c *V1Client) Create{{ .Name }}(ctx context.Context, input *models.{{ .Name }}CreationInput) ({{ camelCase .Name }} *models.{{ .Name }}, err error) {
	req, err := c.BuildCreate{{ .Name }}Request(ctx, input)
	if err != nil {
		return nil, errors.Wrap(err, "building request")
	}

	err = c.executeRequest(ctx, req, &{{ camelCase .Name }})
	return {{ camelCase .Name }}, err
}

// BuildUpdate{{ .Name }}Request builds an HTTP request for updating an {{ camelCase .Name }}
func (c *V1Client) BuildUpdate{{ .Name }}Request(ctx context.Context, updated *models.{{ .Name }}) (*http.Request, error) {
	uri := c.BuildURL(nil, {{ camelCase .Name }}sBasePath, strconv.FormatUint(updated.ID, 10))

	return c.buildDataRequest(http.MethodPut, uri, updated)
}

// Update{{ .Name }} updates an {{ camelCase .Name }}
func (c *V1Client) Update{{ .Name }}(ctx context.Context, updated *models.{{ .Name }}) error {
	req, err := c.BuildUpdate{{ .Name }}Request(ctx, updated)
	if err != nil {
		return errors.Wrap(err, "building request")
	}

	return c.executeRequest(ctx, req, &updated)
}

// BuildArchive{{ .Name }}Request builds an HTTP request for updating an {{ camelCase .Name }}
func (c *V1Client) BuildArchive{{ .Name }}Request(ctx context.Context, id uint64) (*http.Request, error) {
	uri := c.BuildURL(nil, {{ camelCase .Name }}sBasePath, strconv.FormatUint(id, 10))

	return http.NewRequest(http.MethodDelete, uri, nil)
}

// Archive{{ .Name }} archives an {{ camelCase .Name }}
func (c *V1Client) Archive{{ .Name }}(ctx context.Context, id uint64) error {
	req, err := c.BuildArchive{{ .Name }}Request(ctx, id)
	if err != nil {
		return errors.Wrap(err, "building request")
	}

	return c.executeRequest(ctx, req, nil)
}
