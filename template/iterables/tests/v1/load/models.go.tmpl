package main

import (
	"context"
	"math/rand"
	"net/http"

	client "{{ .OutputRepository }}/client/v1/http"
	"{{ .OutputRepository }}/models/v1"
	randmodel "{{ .OutputRepository }}/tests/v1/testutil/rand/model"
)

// fetchRandom{{ .Name }} retrieves a random {{ camelCase .Name }} from the list of available {{ camelCase .Name }}s
func fetchRandom{{ .Name }}(c *client.V1Client) *models.{{ .Name }} {
	{{ camelCase .Name }}sRes, err := c.Get{{ .Name }}s(context.Background(), nil)
	if err != nil || {{ camelCase .Name }}sRes == nil || len({{ camelCase .Name }}sRes.{{ .Name }}s) == 0 {
		return nil
	}

	randIndex := rand.Intn(len({{ camelCase .Name }}sRes.{{ .Name }}s))
	return &{{ camelCase .Name }}sRes.{{ .Name }}s[randIndex]
}

func build{{ .Name }}Actions(c *client.V1Client) map[string]*Action {
	return map[string]*Action{
		"Create{{ .Name }}": {
			Name: "Create{{ .Name }}",
			Action: func() (*http.Request, error) {
				return c.BuildCreate{{ .Name }}Request(context.Background(), randmodel.Random{{ .Name }}CreationInput())
			},
			Weight: 100,
		},
		"Get{{ .Name }}": {
			Name: "Get{{ .Name }}",
			Action: func() (*http.Request, error) {
				if random{{ .Name }} := fetchRandom{{ .Name }}(c); random{{ .Name }} != nil {
					return c.BuildGet{{ .Name }}Request(context.Background(), random{{ .Name }}.ID)
				}
				return nil, ErrUnavailableYet
			},
			Weight: 100,
		},
		"Get{{ .Name }}s": {
			Name: "Get{{ .Name }}s",
			Action: func() (*http.Request, error) {
				return c.BuildGet{{ .Name }}sRequest(context.Background(), nil)
			},
			Weight: 100,
		},
		"Update{{ .Name }}": {
			Name: "Update{{ .Name }}",
			Action: func() (*http.Request, error) {
				if random{{ .Name }} := fetchRandom{{ .Name }}(c); random{{ .Name }} != nil {
					random{{ .Name }}.Name = randmodel.Random{{ .Name }}CreationInput().Name
					return c.BuildUpdate{{ .Name }}Request(context.Background(), random{{ .Name }})
				}
				return nil, ErrUnavailableYet
			},
			Weight: 100,
		},
		"Archive{{ .Name }}": {
			Name: "Archive{{ .Name }}",
			Action: func() (*http.Request, error) {
				if random{{ .Name }} := fetchRandom{{ .Name }}(c); random{{ .Name }} != nil {
					return c.BuildArchive{{ .Name }}Request(context.Background(), random{{ .Name }}.ID)
				}
				return nil, ErrUnavailableYet
			},
			Weight: 85,
		},
	}
}
