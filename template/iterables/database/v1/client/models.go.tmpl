package dbclient

import (
	"context"
	"strconv"

	"{{ .OutputRepository }}/models/v1"

	"go.opencensus.io/trace"
)

var _ models.{{ camelcase .Name }}DataManager = (*Client)(nil)

// attach{{ camelcase .Name }}IDToSpan provides a consistent way to attach an {{ lower .Name }}'s ID to a span
func attach{{ camelcase .Name }}IDToSpan(span *trace.Span, {{ lower .Name }}ID uint64) {
	if span != nil {
		span.AddAttributes(trace.StringAttribute("{{ lower .Name }}_id", strconv.FormatUint({{ lower .Name }}ID, 10)))
	}
}

// Get{{ camelcase .Name }} fetches an {{ lower .Name }} from the database
func (c *Client) Get{{ camelcase .Name }}(ctx context.Context, {{ lower .Name }}ID, userID uint64) (*models.{{ camelcase .Name }}, error) {
	ctx, span := trace.StartSpan(ctx, "Get{{ camelcase .Name }}")
	defer span.End()

	attachUserIDToSpan(span, userID)
	attach{{ camelcase .Name }}IDToSpan(span, {{ lower .Name }}ID)

	c.logger.WithValues(map[string]interface{}{
		"{{ lower .Name }}_id": {{ lower .Name }}ID,
		"user_id": userID,
	}).Debug("Get{{ camelcase .Name }} called")

	return c.querier.Get{{ camelcase .Name }}(ctx, {{ lower .Name }}ID, userID)
}

// Get{{ camelcase .Name }}Count fetches the count of {{ lower .Name }}s from the database that meet a particular filter
func (c *Client) Get{{ camelcase .Name }}Count(ctx context.Context, filter *models.QueryFilter, userID uint64) (count uint64, err error) {
	ctx, span := trace.StartSpan(ctx, "Get{{ camelcase .Name }}Count")
	defer span.End()

	attachUserIDToSpan(span, userID)
	attachFilterToSpan(span, filter)

	c.logger.WithValue("user_id", userID).Debug("Get{{ camelcase .Name }}Count called")

	return c.querier.Get{{ camelcase .Name }}Count(ctx, filter, userID)
}

// GetAll{{ camelcase .Name }}sCount fetches the count of {{ lower .Name }}s from the database that meet a particular filter
func (c *Client) GetAll{{ camelcase .Name }}sCount(ctx context.Context) (count uint64, err error) {
	ctx, span := trace.StartSpan(ctx, "GetAll{{ camelcase .Name }}sCount")
	defer span.End()

	c.logger.Debug("GetAll{{ camelcase .Name }}sCount called")

	return c.querier.GetAll{{ camelcase .Name }}sCount(ctx)
}

// Get{{ camelcase .Name }}s fetches a list of {{ lower .Name }}s from the database that meet a particular filter
func (c *Client) Get{{ camelcase .Name }}s(ctx context.Context, filter *models.QueryFilter, userID uint64) (*models.{{ camelcase .Name }}List, error) {
	ctx, span := trace.StartSpan(ctx, "Get{{ camelcase .Name }}s")
	defer span.End()

	attachUserIDToSpan(span, userID)
	attachFilterToSpan(span, filter)

	c.logger.WithValue("user_id", userID).Debug("Get{{ camelcase .Name }}s called")

	{{ lower .Name }}List, err := c.querier.Get{{ camelcase .Name }}s(ctx, filter, userID)

	return {{ lower .Name }}List, err
}

// GetAll{{ camelcase .Name }}sForUser fetches a list of {{ lower .Name }}s from the database that meet a particular filter
func (c *Client) GetAll{{ camelcase .Name }}sForUser(ctx context.Context, userID uint64) ([]models.{{ camelcase .Name }}, error) {
	ctx, span := trace.StartSpan(ctx, "GetAll{{ camelcase .Name }}sForUser")
	defer span.End()

	attachUserIDToSpan(span, userID)
	c.logger.WithValue("user_id", userID).Debug("GetAll{{ camelcase .Name }}sForUser called")

	{{ lower .Name }}List, err := c.querier.GetAll{{ camelcase .Name }}sForUser(ctx, userID)

	return {{ lower .Name }}List, err
}

// Create{{ camelcase .Name }} creates an {{ lower .Name }} in the database
func (c *Client) Create{{ camelcase .Name }}(ctx context.Context, input *models.{{ camelcase .Name }}CreationInput) (*models.{{ camelcase .Name }}, error) {
	ctx, span := trace.StartSpan(ctx, "Create{{ camelcase .Name }}")
	defer span.End()

	c.logger.WithValue("input", input).Debug("Create{{ camelcase .Name }} called")

	return c.querier.Create{{ camelcase .Name }}(ctx, input)
}

// Update{{ camelcase .Name }} updates a particular {{ lower .Name }}. Note that Update{{ camelcase .Name }} expects the
// provided input to have a valid ID.
func (c *Client) Update{{ camelcase .Name }}(ctx context.Context, input *models.{{ camelcase .Name }}) error {
	ctx, span := trace.StartSpan(ctx, "Update{{ camelcase .Name }}")
	defer span.End()

	attach{{ camelcase .Name }}IDToSpan(span, input.ID)
	c.logger.WithValue("{{ lower .Name }}_id", input.ID).Debug("Update{{ camelcase .Name }} called")

	return c.querier.Update{{ camelcase .Name }}(ctx, input)
}

// Archive{{ camelcase .Name }} archives an {{ lower .Name }} from the database by its ID
func (c *Client) Archive{{ camelcase .Name }}(ctx context.Context, {{ lower .Name }}ID, userID uint64) error {
	ctx, span := trace.StartSpan(ctx, "Archive{{ camelcase .Name }}")
	defer span.End()

	attachUserIDToSpan(span, userID)
	attach{{ camelcase .Name }}IDToSpan(span, {{ lower .Name }}ID)

	c.logger.WithValues(map[string]interface{}{
		"{{ lower .Name }}_id": {{ lower .Name }}ID,
		"user_id": userID,
	}).Debug("Archive{{ camelcase .Name }} called")

	return c.querier.Archive{{ camelcase .Name }}(ctx, {{ lower .Name }}ID, userID)
}
