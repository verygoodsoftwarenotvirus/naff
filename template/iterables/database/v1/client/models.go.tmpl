package dbclient

import (
	"context"
	"strconv"

	"{{ .OutputRepository }}/models/v1"

	"go.opencensus.io/trace"
)

var _ models.{{ .Name }}DataManager = (*Client)(nil)

// attach{{ .Name }}IDToSpan provides a consistent way to attach an {{ camelCase .Name }}'s ID to a span
func attach{{ .Name }}IDToSpan(span *trace.Span, {{ camelCase .Name }}ID uint64) {
	if span != nil {
		span.AddAttributes(trace.StringAttribute("{{ camelCase .Name }}_id", strconv.FormatUint({{ camelCase .Name }}ID, 10)))
	}
}

// Get{{ .Name }} fetches an {{ camelCase .Name }} from the database
func (c *Client) Get{{ .Name }}(ctx context.Context, {{ camelCase .Name }}ID, userID uint64) (*models.{{ .Name }}, error) {
	ctx, span := trace.StartSpan(ctx, "Get{{ .Name }}")
	defer span.End()

	attachUserIDToSpan(span, userID)
	attach{{ .Name }}IDToSpan(span, {{ camelCase .Name }}ID)

	c.logger.WithValues(map[string]interface{}{
		"{{ camelCase .Name }}_id": {{ camelCase .Name }}ID,
		"user_id": userID,
	}).Debug("Get{{ .Name }} called")

	return c.querier.Get{{ .Name }}(ctx, {{ camelCase .Name }}ID, userID)
}

// Get{{ .Name }}Count fetches the count of {{ camelCase .Name }}s from the database that meet a particular filter
func (c *Client) Get{{ .Name }}Count(ctx context.Context, filter *models.QueryFilter, userID uint64) (count uint64, err error) {
	ctx, span := trace.StartSpan(ctx, "Get{{ .Name }}Count")
	defer span.End()

	attachUserIDToSpan(span, userID)
	attachFilterToSpan(span, filter)

	c.logger.WithValue("user_id", userID).Debug("Get{{ .Name }}Count called")

	return c.querier.Get{{ .Name }}Count(ctx, filter, userID)
}

// GetAll{{ .Name }}sCount fetches the count of {{ camelCase .Name }}s from the database that meet a particular filter
func (c *Client) GetAll{{ .Name }}sCount(ctx context.Context) (count uint64, err error) {
	ctx, span := trace.StartSpan(ctx, "GetAll{{ .Name }}sCount")
	defer span.End()

	c.logger.Debug("GetAll{{ .Name }}sCount called")

	return c.querier.GetAll{{ .Name }}sCount(ctx)
}

// Get{{ .Name }}s fetches a list of {{ camelCase .Name }}s from the database that meet a particular filter
func (c *Client) Get{{ .Name }}s(ctx context.Context, filter *models.QueryFilter, userID uint64) (*models.{{ .Name }}List, error) {
	ctx, span := trace.StartSpan(ctx, "Get{{ .Name }}s")
	defer span.End()

	attachUserIDToSpan(span, userID)
	attachFilterToSpan(span, filter)

	c.logger.WithValue("user_id", userID).Debug("Get{{ .Name }}s called")

	{{ camelCase .Name }}List, err := c.querier.Get{{ .Name }}s(ctx, filter, userID)

	return {{ camelCase .Name }}List, err
}

// GetAll{{ .Name }}sForUser fetches a list of {{ camelCase .Name }}s from the database that meet a particular filter
func (c *Client) GetAll{{ .Name }}sForUser(ctx context.Context, userID uint64) ([]models.{{ .Name }}, error) {
	ctx, span := trace.StartSpan(ctx, "GetAll{{ .Name }}sForUser")
	defer span.End()

	attachUserIDToSpan(span, userID)
	c.logger.WithValue("user_id", userID).Debug("GetAll{{ .Name }}sForUser called")

	{{ camelCase .Name }}List, err := c.querier.GetAll{{ .Name }}sForUser(ctx, userID)

	return {{ camelCase .Name }}List, err
}

// Create{{ .Name }} creates an {{ camelCase .Name }} in the database
func (c *Client) Create{{ .Name }}(ctx context.Context, input *models.{{ .Name }}CreationInput) (*models.{{ .Name }}, error) {
	ctx, span := trace.StartSpan(ctx, "Create{{ .Name }}")
	defer span.End()

	c.logger.WithValue("input", input).Debug("Create{{ .Name }} called")

	return c.querier.Create{{ .Name }}(ctx, input)
}

// Update{{ .Name }} updates a particular {{ camelCase .Name }}. Note that Update{{ .Name }} expects the
// provided input to have a valid ID.
func (c *Client) Update{{ .Name }}(ctx context.Context, input *models.{{ .Name }}) error {
	ctx, span := trace.StartSpan(ctx, "Update{{ .Name }}")
	defer span.End()

	attach{{ .Name }}IDToSpan(span, input.ID)
	c.logger.WithValue("{{ camelCase .Name }}_id", input.ID).Debug("Update{{ .Name }} called")

	return c.querier.Update{{ .Name }}(ctx, input)
}

// Archive{{ .Name }} archives an {{ camelCase .Name }} from the database by its ID
func (c *Client) Archive{{ .Name }}(ctx context.Context, {{ camelCase .Name }}ID, userID uint64) error {
	ctx, span := trace.StartSpan(ctx, "Archive{{ .Name }}")
	defer span.End()

	attachUserIDToSpan(span, userID)
	attach{{ .Name }}IDToSpan(span, {{ camelCase .Name }}ID)

	c.logger.WithValues(map[string]interface{}{
		"{{ camelCase .Name }}_id": {{ camelCase .Name }}ID,
		"user_id": userID,
	}).Debug("Archive{{ .Name }} called")

	return c.querier.Archive{{ .Name }}(ctx, {{ camelCase .Name }}ID, userID)
}
