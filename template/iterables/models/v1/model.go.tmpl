package models

import (
	"context"
	"net/http"
)

type (
	// {{ .Name }} represents a(n) {{ .Name }}
	{{ .Name }} struct {
		ID         uint64  `json:"id"`
		{{ range $i, $field := .Fields }}
			{{ pascal $field.Name }} {{ if $field.Pointer }}*{{ end }}{{ $field.Type }} `json:"{{ snakecase $field.Name }}"`
		{{ end }}
		CreatedOn  uint64  `json:"created_on"`
		UpdatedOn  *uint64 `json:"updated_on"`
		ArchivedOn *uint64 `json:"archived_on"`
		BelongsTo  uint64  `json:"belongs_to"`
	}

	// {{ .Name }}List represents a list of {{ camelCase .Name }}s
	{{ .Name }}List struct {
		Pagination
		{{ .Name }}s []{{ .Name }} `json:"{{ camelCase .Name }}s"`
	}

	// {{ .Name }}CreationInput represents what a user could set as input for creating {{ .Name }}s
	{{ .Name }}CreationInput struct {
		{{ range $i, $field := .Fields }}
			{{ if $field.ValidForCreationInput }}
				{{ $field.Name }} {{ if $field.Pointer }}*{{ end }}{{ $field.Type }} `json:"{{ snakecase $field.Name }}"`
			{{ end }}
		{{ end }}
		BelongsTo uint64 `json:"-"`
	}

	// {{ .Name }}UpdateInput represents what a user could set as input for updating {{ .Name }}s
	{{ .Name }}UpdateInput struct {
		{{ range $i, $field := .Fields }}
			{{ if $field.ValidForUpdateInput }}
				{{ $field.Name }} {{ if $field.Pointer }}*{{ end }}{{ $field.Type }} `json:"{{ snakecase $field.Name }}"`
			{{ end }}
		{{ end }}
		BelongsTo uint64 `json:"-"`
	}

	// {{ .Name }}DataManager describes a structure capable of storing {{ camelCase .Name }}s permanently
	{{ .Name }}DataManager interface {
		Get{{ .Name }}(ctx context.Context, {{ camelCase .Name }}ID, userID uint64) (*{{ .Name }}, error)
		Get{{ .Name }}Count(ctx context.Context, filter *QueryFilter, userID uint64) (uint64, error)
		GetAll{{ .Name }}sCount(ctx context.Context) (uint64, error)
		Get{{ .Name }}s(ctx context.Context, filter *QueryFilter, userID uint64) (*{{ .Name }}List, error)
		GetAll{{ .Name }}sForUser(ctx context.Context, userID uint64) ([]{{ .Name }}, error)
		Create{{ .Name }}(ctx context.Context, input *{{ .Name }}CreationInput) (*{{ .Name }}, error)
		Update{{ .Name }}(ctx context.Context, updated *{{ .Name }}) error
		Archive{{ .Name }}(ctx context.Context, id, userID uint64) error
	}

	// {{ .Name }}DataServer describes a structure capable of serving traffic related to {{ camelCase .Name }}s
	{{ .Name }}DataServer interface {
		CreationInputMiddleware(next http.Handler) http.Handler
		UpdateInputMiddleware(next http.Handler) http.Handler

		ListHandler(res http.ResponseWriter, req *http.Request)
		CreateHandler(res http.ResponseWriter, req *http.Request)
		ReadHandler(res http.ResponseWriter, req *http.Request)
		UpdateHandler(res http.ResponseWriter, req *http.Request)
		ArchiveHandler(res http.ResponseWriter, req *http.Request)
	}
)

// Update merges an {{ .Name }}Input with an {{ .Name }}
func (x *{{ .Name }}) Update(input *{{ .Name }}UpdateInput) {
	{{ range $i, $field := .Fields }}
		{{ if $field.ValidForUpdateInput }}
		if x.{{ $field.Name }} != input.{{ $field.Name }} {
			x.{{ $field.Name }} = input.{{ $field.Name }}
		}{{ end }}
{{ end }}
}
