package models

import (
	"context"
	"net/http"
)

type (
	// {{ camelcase .Name }} represents a(n) {{ camelcase .Name }}
	{{ camelcase .Name }} struct {
		ID         uint64  `json:"id"`
		{{ range $i, $field := .Fields }}
			{{ pascal $field.Name }} {{ if $field.Pointer }}*{{ end }}{{ $field.Type }} `json:"{{ snakecase $field.Name }}"`
		{{ end }}
		CreatedOn  uint64  `json:"created_on"`
		UpdatedOn  *uint64 `json:"updated_on"`
		ArchivedOn *uint64 `json:"archived_on"`
		BelongsTo  uint64  `json:"belongs_to"`
	}

	// {{ camelcase .Name }}List represents a list of {{ lower .Name }}s
	{{ camelcase .Name }}List struct {
		Pagination
		{{ camelcase .Name }}s []{{ camelcase .Name }} `json:"{{ lower .Name }}s"`
	}

	// {{ camelcase .Name }}CreationInput represents what a user could set as input for creating {{ camelcase .Name }}s
	{{ camelcase .Name }}CreationInput struct {
		{{ range $i, $field := .Fields }}
			{{ if $field.ValidForCreationInput }}
				{{ $field.Name }} {{ if $field.Pointer }}*{{ end }}{{ $field.Type }} `json:"{{ snakecase $field.Name }}"`
			{{ end }}
		{{ end }}
		BelongsTo uint64 `json:"-"`
	}

	// {{ camelcase .Name }}UpdateInput represents what a user could set as input for updating {{ camelcase .Name }}s
	{{ camelcase .Name }}UpdateInput struct {
		{{ range $i, $field := .Fields }}
			{{ if $field.ValidForUpdateInput }}
				{{ $field.Name }} {{ if $field.Pointer }}*{{ end }}{{ $field.Type }} `json:"{{ snakecase $field.Name }}"`
			{{ end }}
		{{ end }}
		BelongsTo uint64 `json:"-"`
	}

	// {{ camelcase .Name }}DataManager describes a structure capable of storing {{ lower .Name }}s permanently
	{{ camelcase .Name }}DataManager interface {
		Get{{ camelcase .Name }}(ctx context.Context, {{ lower .Name }}ID, userID uint64) (*{{ camelcase .Name }}, error)
		Get{{ camelcase .Name }}Count(ctx context.Context, filter *QueryFilter, userID uint64) (uint64, error)
		GetAll{{ camelcase .Name }}sCount(ctx context.Context) (uint64, error)
		Get{{ camelcase .Name }}s(ctx context.Context, filter *QueryFilter, userID uint64) (*{{ camelcase .Name }}List, error)
		GetAll{{ camelcase .Name }}sForUser(ctx context.Context, userID uint64) ([]{{ camelcase .Name }}, error)
		Create{{ camelcase .Name }}(ctx context.Context, input *{{ camelcase .Name }}CreationInput) (*{{ camelcase .Name }}, error)
		Update{{ camelcase .Name }}(ctx context.Context, updated *{{ camelcase .Name }}) error
		Archive{{ camelcase .Name }}(ctx context.Context, id, userID uint64) error
	}

	// {{ camelcase .Name }}DataServer describes a structure capable of serving traffic related to {{ lower .Name }}s
	{{ camelcase .Name }}DataServer interface {
		CreationInputMiddleware(next http.Handler) http.Handler
		UpdateInputMiddleware(next http.Handler) http.Handler

		ListHandler(res http.ResponseWriter, req *http.Request)
		CreateHandler(res http.ResponseWriter, req *http.Request)
		ReadHandler(res http.ResponseWriter, req *http.Request)
		UpdateHandler(res http.ResponseWriter, req *http.Request)
		ArchiveHandler(res http.ResponseWriter, req *http.Request)
	}
)

// Update merges an {{ camelcase .Name }}Input with an {{ camelcase .Name }}
func (x *{{ camelcase .Name }}) Update(input *{{ camelcase .Name }}UpdateInput) {
	{{ range $i, $field := .Fields }}
		{{ if $field.ValidForUpdateInput }} 
		if x.{{ $field.Name }} != input.{{ $field.Name }} {
			x.{{ $field.Name }} = input.{{ $field.Name }} 
		}{{ end }}
{{ end }}
}
